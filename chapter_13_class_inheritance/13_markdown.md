
将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting)，

相反的过程--将基类指针或引用转换为派生类指针或引用--称为向下强制转换(downcasting)。如果不适用显示类型转换，则向下强制转换是不允许的。

#### 虚函数的工作原理
编译器处理虚函数的方法：给每个对象添加一个隐藏成员。该隐藏成员保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table, vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址。

例如：基类队形包含一个指针，该指针指向基类中所有的虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中。

### 13.4.3 有关虚函数的注意事项

#### 1. 构造函数
构造函数不能是虚函数。派生类有自己的构造函数，而不是继承基类的构造函数。即使派生类没有定义构造函数，默认的构造函数也会在内部调用基类的构造函数，这不是虚函数。

#### 2. 析构函数
析构函数应当是虚函数，除非类不用做基类。

#### 3. 友元
右元不嫩是虚函数，因为友元不是类成员，只有成员才能是虚函数。

#### 4. 没有重新定义
如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新版本的虚函数，例外的情况是基类版本是隐藏的。

#### 5. 重新定义将隐藏方法
假设创建了如下代码：
```cpp
class Dwelling {
public:
    virtual void showperks(int a) const;
...
};

class Hovel : public Dwelling {
public:
    virtual void showperks() const;
...
};
```

这将导致问题，可能会出现类似下面的编译警告：
```
Warning: Hovel::showperks(void) hides Dwelling::showperks(int)
```

也可能不会出现警告。但是代码如下会有问题:
```cpp
Hovel trump;
trump.showperks();      // valid
trump.showperks(3);     // invalid
```
